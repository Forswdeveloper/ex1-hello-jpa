프록시 지연,즉시로딩

즉시로딩 주의사항

실부에서는 지연로딩만 사용하도록 해야함

즉시 로딩을 적용하면 예상하지 못한 SQL이 발생함
즉시로딩은 JPQL에서 N+1 문제를 일으킨다.

@ManyToOne, @OneToOne은 기본이 즉시 로딩  -> LAZY로 설정해야함

@OneToMany, @ManyToMany는 기본이 지연로딩

Team teamA = new Team();
            teamA.setName("TeamA");
            em.persist(teamA);

            Team teamB = new Team();
            teamB.setName("TeamB");
            em.persist(teamB);

            Member member1 = new Member();
            member1.setUsername("Member1");
            member1.setTeam(teamA);
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("Member2");
            member2.setTeam(teamB);
            em.persist(member2);

            em.flush();
            em.clear();

//            Member findMember = em.find(Member.class, member1.getId());
//            System.out.println("findMember = " + findMember.getTeam().getClass());
//            System.out.println("-----------------------------------------");
//            System.out.println("Team Name : " + member1.getTeam().getName()); //지연로딩 설정으로 인해 team 사용 시 초기화

            //즉시로딩 설정 시 값이 존재해야 하므로 쿼리 조회 시 부하 발생.
            //Fetch join 설정으로 값 동시 조회하여 부하 제거
            List<Member> members = em.createQuery("select m from Member m join fetch m.team", Member.class)
                    .getResultList();


